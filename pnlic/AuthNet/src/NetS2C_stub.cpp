  





// Generated by PIDL compiler.
// Do not modify this file, but modify the source .pidl file.

  
#include "NetS2C_stub.h"



const unsigned char sz_NetS2C_stub_hRmi[] = 
{ 0x00, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xff, 0x00, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xff,
0xaa, 0xbb, 0xcc, 0xdd, 0xff,0x99, 0xaa, 0xbb, 0xcc, 0x99, 0xaa, 0xdd, 0xff, 0x00 };   


namespace ProudS2C {


	bool Stub::ProcessReceivedMessage(::Proud::CReceivedMessage &pa, void* hostTag) 
	{
#ifndef __FreeBSD__ 
		{
			// unusable but required. you may ignore it, because it does not occur any worthless load.
			unsigned char x = sz_NetS2C_stub_hRmi[0]; 
			x++; 
		}
#endif
		::Proud::HostID remote=pa.GetRemoteHostID();
		if(remote==::Proud::HostID_None)
		{
			ShowUnknownHostIDWarning(remote);
		}

		::Proud::CMessage &__msg=pa.GetReadOnlyMessage();
		int orgReadOffset = __msg.GetReadOffset();

		::Proud::RmiID __rmiID;
		if(!__msg.Read(__rmiID))
			goto __fail;
					
		switch((int)__rmiID) // case is to prevent from clang compile error
		{
			case Rmi_P2PGroup_MemberJoin:
				{
					::Proud::RmiContext ctx;
					ctx.m_rmiID = __rmiID;
					ctx.m_sentFrom=pa.GetRemoteHostID();
					ctx.m_relayed=pa.IsRelayed();
					ctx.m_hostTag = hostTag;
					ctx.m_encryptMode = pa.GetEncryptMode();
					ctx.m_compressMode = pa.GetCompressMode();
			
			        if(BeforeDeserialize(remote, ctx, __msg) == false)
			        {
			            // The user don't want to call the RMI function. 
						// So, We fake that it has been already called.
						__msg.SetReadOffset(__msg.GetLength());
			            return true;
			        }
			
					HostID groupHostID; __msg >> groupHostID;
					HostID memberHostID; __msg >> memberHostID;
					ByteArray customField; __msg >> customField;
					int eventID; __msg >> eventID;
					ByteArray p2pAESSessionKey; __msg >> p2pAESSessionKey;
					ByteArray p2pFastSessionKey; __msg >> p2pFastSessionKey;
					int p2pFirstFrameNumber; __msg >> p2pFirstFrameNumber;
					Proud::Guid connectionMagicNumber; __msg >> connectionMagicNumber;
					bool allowDirectP2P; __msg >> allowDirectP2P;
					bool pairRecycled; __msg >> pairRecycled;
					m_core->PostCheckReadMessage(__msg,RmiName_P2PGroup_MemberJoin);
					
			
					if(m_enableNotifyCallFromStub && !m_internalUse)
					{
						::Proud::String parameterString;
						
						::Proud::AppendTextOut(parameterString,groupHostID);	
										
						parameterString += _PNT(", ");
						::Proud::AppendTextOut(parameterString,memberHostID);	
										
						parameterString += _PNT(", ");
						::Proud::AppendTextOut(parameterString,customField);	
										
						parameterString += _PNT(", ");
						::Proud::AppendTextOut(parameterString,eventID);	
										
						parameterString += _PNT(", ");
						::Proud::AppendTextOut(parameterString,p2pAESSessionKey);	
										
						parameterString += _PNT(", ");
						::Proud::AppendTextOut(parameterString,p2pFastSessionKey);	
										
						parameterString += _PNT(", ");
						::Proud::AppendTextOut(parameterString,p2pFirstFrameNumber);	
										
						parameterString += _PNT(", ");
						::Proud::AppendTextOut(parameterString,connectionMagicNumber);	
										
						parameterString += _PNT(", ");
						::Proud::AppendTextOut(parameterString,allowDirectP2P);	
										
						parameterString += _PNT(", ");
						::Proud::AppendTextOut(parameterString,pairRecycled);	
						
						NotifyCallFromStub(remote, (::Proud::RmiID)Rmi_P2PGroup_MemberJoin, 
							RmiName_P2PGroup_MemberJoin,parameterString);
			
			#ifdef VIZAGENT
						m_core->Viz_NotifyRecvToStub(remote, (::Proud::RmiID)Rmi_P2PGroup_MemberJoin, 
							RmiName_P2PGroup_MemberJoin, parameterString);
			#endif
					}
					else if(!m_internalUse)
					{
			#ifdef VIZAGENT
						m_core->Viz_NotifyRecvToStub(remote, (::Proud::RmiID)Rmi_P2PGroup_MemberJoin, 
							RmiName_P2PGroup_MemberJoin, _PNT(""));
			#endif
					}
						
					int64_t __t0 = 0;
					if(!m_internalUse)
					{
						if(m_enableStubProfiling)
						{
							::Proud::BeforeRmiSummary __summary;
							__summary.m_rmiID = (::Proud::RmiID)Rmi_P2PGroup_MemberJoin;
							__summary.m_rmiName = RmiName_P2PGroup_MemberJoin;
							__summary.m_hostID = remote;
							__summary.m_hostTag = hostTag;
							BeforeRmiInvocation(__summary);
							__t0 = ::Proud::GetPreciseCurrentTimeMs();
						}
					}
						
					// Call this method.
					bool __ret = P2PGroup_MemberJoin (remote,ctx , groupHostID, memberHostID, customField, eventID, p2pAESSessionKey, p2pFastSessionKey, p2pFirstFrameNumber, connectionMagicNumber, allowDirectP2P, pairRecycled );
						
					if(__ret==false)
					{
						// Error: RMI function that a user did not create has been called. 
						m_core->ShowNotImplementedRmiWarning(RmiName_P2PGroup_MemberJoin);
					}
			
					int64_t __t1;
			
					if(!m_internalUse && m_enableStubProfiling)
					{
						__t1 = ::Proud::GetPreciseCurrentTimeMs() - __t0;
			
						::Proud::AfterRmiSummary __summary;
						__summary.m_rmiID = (::Proud::RmiID)Rmi_P2PGroup_MemberJoin;
						__summary.m_rmiName = RmiName_P2PGroup_MemberJoin;
						__summary.m_hostID = remote;
						__summary.m_hostTag = hostTag;
			
						__summary.m_elapsedTime = (uint32_t)__t1;
			
						AfterRmiInvocation(__summary);
					}
				}
				break;
			case Rmi_RequestP2PHolepunch:
				{
					::Proud::RmiContext ctx;
					ctx.m_rmiID = __rmiID;
					ctx.m_sentFrom=pa.GetRemoteHostID();
					ctx.m_relayed=pa.IsRelayed();
					ctx.m_hostTag = hostTag;
					ctx.m_encryptMode = pa.GetEncryptMode();
					ctx.m_compressMode = pa.GetCompressMode();
			
			        if(BeforeDeserialize(remote, ctx, __msg) == false)
			        {
			            // The user don't want to call the RMI function. 
						// So, We fake that it has been already called.
						__msg.SetReadOffset(__msg.GetLength());
			            return true;
			        }
			
					HostID remotePeerID; __msg >> remotePeerID;
					AddrPort internalAddr; __msg >> internalAddr;
					AddrPort externalAddr; __msg >> externalAddr;
					m_core->PostCheckReadMessage(__msg,RmiName_RequestP2PHolepunch);
					
			
					if(m_enableNotifyCallFromStub && !m_internalUse)
					{
						::Proud::String parameterString;
						
						::Proud::AppendTextOut(parameterString,remotePeerID);	
										
						parameterString += _PNT(", ");
						::Proud::AppendTextOut(parameterString,internalAddr);	
										
						parameterString += _PNT(", ");
						::Proud::AppendTextOut(parameterString,externalAddr);	
						
						NotifyCallFromStub(remote, (::Proud::RmiID)Rmi_RequestP2PHolepunch, 
							RmiName_RequestP2PHolepunch,parameterString);
			
			#ifdef VIZAGENT
						m_core->Viz_NotifyRecvToStub(remote, (::Proud::RmiID)Rmi_RequestP2PHolepunch, 
							RmiName_RequestP2PHolepunch, parameterString);
			#endif
					}
					else if(!m_internalUse)
					{
			#ifdef VIZAGENT
						m_core->Viz_NotifyRecvToStub(remote, (::Proud::RmiID)Rmi_RequestP2PHolepunch, 
							RmiName_RequestP2PHolepunch, _PNT(""));
			#endif
					}
						
					int64_t __t0 = 0;
					if(!m_internalUse)
					{
						if(m_enableStubProfiling)
						{
							::Proud::BeforeRmiSummary __summary;
							__summary.m_rmiID = (::Proud::RmiID)Rmi_RequestP2PHolepunch;
							__summary.m_rmiName = RmiName_RequestP2PHolepunch;
							__summary.m_hostID = remote;
							__summary.m_hostTag = hostTag;
							BeforeRmiInvocation(__summary);
							__t0 = ::Proud::GetPreciseCurrentTimeMs();
						}
					}
						
					// Call this method.
					bool __ret = RequestP2PHolepunch (remote,ctx , remotePeerID, internalAddr, externalAddr );
						
					if(__ret==false)
					{
						// Error: RMI function that a user did not create has been called. 
						m_core->ShowNotImplementedRmiWarning(RmiName_RequestP2PHolepunch);
					}
			
					int64_t __t1;
			
					if(!m_internalUse && m_enableStubProfiling)
					{
						__t1 = ::Proud::GetPreciseCurrentTimeMs() - __t0;
			
						::Proud::AfterRmiSummary __summary;
						__summary.m_rmiID = (::Proud::RmiID)Rmi_RequestP2PHolepunch;
						__summary.m_rmiName = RmiName_RequestP2PHolepunch;
						__summary.m_hostID = remote;
						__summary.m_hostTag = hostTag;
			
						__summary.m_elapsedTime = (uint32_t)__t1;
			
						AfterRmiInvocation(__summary);
					}
				}
				break;
			case Rmi_P2P_NotifyDirectP2PDisconnected2:
				{
					::Proud::RmiContext ctx;
					ctx.m_rmiID = __rmiID;
					ctx.m_sentFrom=pa.GetRemoteHostID();
					ctx.m_relayed=pa.IsRelayed();
					ctx.m_hostTag = hostTag;
					ctx.m_encryptMode = pa.GetEncryptMode();
					ctx.m_compressMode = pa.GetCompressMode();
			
			        if(BeforeDeserialize(remote, ctx, __msg) == false)
			        {
			            // The user don't want to call the RMI function. 
						// So, We fake that it has been already called.
						__msg.SetReadOffset(__msg.GetLength());
			            return true;
			        }
			
					HostID remotePeerHostID; __msg >> remotePeerHostID;
					ErrorType reason; __msg >> reason;
					m_core->PostCheckReadMessage(__msg,RmiName_P2P_NotifyDirectP2PDisconnected2);
					
			
					if(m_enableNotifyCallFromStub && !m_internalUse)
					{
						::Proud::String parameterString;
						
						::Proud::AppendTextOut(parameterString,remotePeerHostID);	
										
						parameterString += _PNT(", ");
						::Proud::AppendTextOut(parameterString,reason);	
						
						NotifyCallFromStub(remote, (::Proud::RmiID)Rmi_P2P_NotifyDirectP2PDisconnected2, 
							RmiName_P2P_NotifyDirectP2PDisconnected2,parameterString);
			
			#ifdef VIZAGENT
						m_core->Viz_NotifyRecvToStub(remote, (::Proud::RmiID)Rmi_P2P_NotifyDirectP2PDisconnected2, 
							RmiName_P2P_NotifyDirectP2PDisconnected2, parameterString);
			#endif
					}
					else if(!m_internalUse)
					{
			#ifdef VIZAGENT
						m_core->Viz_NotifyRecvToStub(remote, (::Proud::RmiID)Rmi_P2P_NotifyDirectP2PDisconnected2, 
							RmiName_P2P_NotifyDirectP2PDisconnected2, _PNT(""));
			#endif
					}
						
					int64_t __t0 = 0;
					if(!m_internalUse)
					{
						if(m_enableStubProfiling)
						{
							::Proud::BeforeRmiSummary __summary;
							__summary.m_rmiID = (::Proud::RmiID)Rmi_P2P_NotifyDirectP2PDisconnected2;
							__summary.m_rmiName = RmiName_P2P_NotifyDirectP2PDisconnected2;
							__summary.m_hostID = remote;
							__summary.m_hostTag = hostTag;
							BeforeRmiInvocation(__summary);
							__t0 = ::Proud::GetPreciseCurrentTimeMs();
						}
					}
						
					// Call this method.
					bool __ret = P2P_NotifyDirectP2PDisconnected2 (remote,ctx , remotePeerHostID, reason );
						
					if(__ret==false)
					{
						// Error: RMI function that a user did not create has been called. 
						m_core->ShowNotImplementedRmiWarning(RmiName_P2P_NotifyDirectP2PDisconnected2);
					}
			
					int64_t __t1;
			
					if(!m_internalUse && m_enableStubProfiling)
					{
						__t1 = ::Proud::GetPreciseCurrentTimeMs() - __t0;
			
						::Proud::AfterRmiSummary __summary;
						__summary.m_rmiID = (::Proud::RmiID)Rmi_P2P_NotifyDirectP2PDisconnected2;
						__summary.m_rmiName = RmiName_P2P_NotifyDirectP2PDisconnected2;
						__summary.m_hostID = remote;
						__summary.m_hostTag = hostTag;
			
						__summary.m_elapsedTime = (uint32_t)__t1;
			
						AfterRmiInvocation(__summary);
					}
				}
				break;
			case Rmi_P2P_NotifyP2PMemberOffline:
				{
					::Proud::RmiContext ctx;
					ctx.m_rmiID = __rmiID;
					ctx.m_sentFrom=pa.GetRemoteHostID();
					ctx.m_relayed=pa.IsRelayed();
					ctx.m_hostTag = hostTag;
					ctx.m_encryptMode = pa.GetEncryptMode();
					ctx.m_compressMode = pa.GetCompressMode();
			
			        if(BeforeDeserialize(remote, ctx, __msg) == false)
			        {
			            // The user don't want to call the RMI function. 
						// So, We fake that it has been already called.
						__msg.SetReadOffset(__msg.GetLength());
			            return true;
			        }
			
					HostID remotePeerHostID; __msg >> remotePeerHostID;
					m_core->PostCheckReadMessage(__msg,RmiName_P2P_NotifyP2PMemberOffline);
					
			
					if(m_enableNotifyCallFromStub && !m_internalUse)
					{
						::Proud::String parameterString;
						
						::Proud::AppendTextOut(parameterString,remotePeerHostID);	
						
						NotifyCallFromStub(remote, (::Proud::RmiID)Rmi_P2P_NotifyP2PMemberOffline, 
							RmiName_P2P_NotifyP2PMemberOffline,parameterString);
			
			#ifdef VIZAGENT
						m_core->Viz_NotifyRecvToStub(remote, (::Proud::RmiID)Rmi_P2P_NotifyP2PMemberOffline, 
							RmiName_P2P_NotifyP2PMemberOffline, parameterString);
			#endif
					}
					else if(!m_internalUse)
					{
			#ifdef VIZAGENT
						m_core->Viz_NotifyRecvToStub(remote, (::Proud::RmiID)Rmi_P2P_NotifyP2PMemberOffline, 
							RmiName_P2P_NotifyP2PMemberOffline, _PNT(""));
			#endif
					}
						
					int64_t __t0 = 0;
					if(!m_internalUse)
					{
						if(m_enableStubProfiling)
						{
							::Proud::BeforeRmiSummary __summary;
							__summary.m_rmiID = (::Proud::RmiID)Rmi_P2P_NotifyP2PMemberOffline;
							__summary.m_rmiName = RmiName_P2P_NotifyP2PMemberOffline;
							__summary.m_hostID = remote;
							__summary.m_hostTag = hostTag;
							BeforeRmiInvocation(__summary);
							__t0 = ::Proud::GetPreciseCurrentTimeMs();
						}
					}
						
					// Call this method.
					bool __ret = P2P_NotifyP2PMemberOffline (remote,ctx , remotePeerHostID );
						
					if(__ret==false)
					{
						// Error: RMI function that a user did not create has been called. 
						m_core->ShowNotImplementedRmiWarning(RmiName_P2P_NotifyP2PMemberOffline);
					}
			
					int64_t __t1;
			
					if(!m_internalUse && m_enableStubProfiling)
					{
						__t1 = ::Proud::GetPreciseCurrentTimeMs() - __t0;
			
						::Proud::AfterRmiSummary __summary;
						__summary.m_rmiID = (::Proud::RmiID)Rmi_P2P_NotifyP2PMemberOffline;
						__summary.m_rmiName = RmiName_P2P_NotifyP2PMemberOffline;
						__summary.m_hostID = remote;
						__summary.m_hostTag = hostTag;
			
						__summary.m_elapsedTime = (uint32_t)__t1;
			
						AfterRmiInvocation(__summary);
					}
				}
				break;
			case Rmi_P2P_NotifyP2PMemberOnline:
				{
					::Proud::RmiContext ctx;
					ctx.m_rmiID = __rmiID;
					ctx.m_sentFrom=pa.GetRemoteHostID();
					ctx.m_relayed=pa.IsRelayed();
					ctx.m_hostTag = hostTag;
					ctx.m_encryptMode = pa.GetEncryptMode();
					ctx.m_compressMode = pa.GetCompressMode();
			
			        if(BeforeDeserialize(remote, ctx, __msg) == false)
			        {
			            // The user don't want to call the RMI function. 
						// So, We fake that it has been already called.
						__msg.SetReadOffset(__msg.GetLength());
			            return true;
			        }
			
					HostID remotePeerHostID; __msg >> remotePeerHostID;
					m_core->PostCheckReadMessage(__msg,RmiName_P2P_NotifyP2PMemberOnline);
					
			
					if(m_enableNotifyCallFromStub && !m_internalUse)
					{
						::Proud::String parameterString;
						
						::Proud::AppendTextOut(parameterString,remotePeerHostID);	
						
						NotifyCallFromStub(remote, (::Proud::RmiID)Rmi_P2P_NotifyP2PMemberOnline, 
							RmiName_P2P_NotifyP2PMemberOnline,parameterString);
			
			#ifdef VIZAGENT
						m_core->Viz_NotifyRecvToStub(remote, (::Proud::RmiID)Rmi_P2P_NotifyP2PMemberOnline, 
							RmiName_P2P_NotifyP2PMemberOnline, parameterString);
			#endif
					}
					else if(!m_internalUse)
					{
			#ifdef VIZAGENT
						m_core->Viz_NotifyRecvToStub(remote, (::Proud::RmiID)Rmi_P2P_NotifyP2PMemberOnline, 
							RmiName_P2P_NotifyP2PMemberOnline, _PNT(""));
			#endif
					}
						
					int64_t __t0 = 0;
					if(!m_internalUse)
					{
						if(m_enableStubProfiling)
						{
							::Proud::BeforeRmiSummary __summary;
							__summary.m_rmiID = (::Proud::RmiID)Rmi_P2P_NotifyP2PMemberOnline;
							__summary.m_rmiName = RmiName_P2P_NotifyP2PMemberOnline;
							__summary.m_hostID = remote;
							__summary.m_hostTag = hostTag;
							BeforeRmiInvocation(__summary);
							__t0 = ::Proud::GetPreciseCurrentTimeMs();
						}
					}
						
					// Call this method.
					bool __ret = P2P_NotifyP2PMemberOnline (remote,ctx , remotePeerHostID );
						
					if(__ret==false)
					{
						// Error: RMI function that a user did not create has been called. 
						m_core->ShowNotImplementedRmiWarning(RmiName_P2P_NotifyP2PMemberOnline);
					}
			
					int64_t __t1;
			
					if(!m_internalUse && m_enableStubProfiling)
					{
						__t1 = ::Proud::GetPreciseCurrentTimeMs() - __t0;
			
						::Proud::AfterRmiSummary __summary;
						__summary.m_rmiID = (::Proud::RmiID)Rmi_P2P_NotifyP2PMemberOnline;
						__summary.m_rmiName = RmiName_P2P_NotifyP2PMemberOnline;
						__summary.m_hostID = remote;
						__summary.m_hostTag = hostTag;
			
						__summary.m_elapsedTime = (uint32_t)__t1;
			
						AfterRmiInvocation(__summary);
					}
				}
				break;
			case Rmi_P2PGroup_MemberLeave:
				{
					::Proud::RmiContext ctx;
					ctx.m_rmiID = __rmiID;
					ctx.m_sentFrom=pa.GetRemoteHostID();
					ctx.m_relayed=pa.IsRelayed();
					ctx.m_hostTag = hostTag;
					ctx.m_encryptMode = pa.GetEncryptMode();
					ctx.m_compressMode = pa.GetCompressMode();
			
			        if(BeforeDeserialize(remote, ctx, __msg) == false)
			        {
			            // The user don't want to call the RMI function. 
						// So, We fake that it has been already called.
						__msg.SetReadOffset(__msg.GetLength());
			            return true;
			        }
			
					HostID memberHostID; __msg >> memberHostID;
					HostID groupHostID; __msg >> groupHostID;
					m_core->PostCheckReadMessage(__msg,RmiName_P2PGroup_MemberLeave);
					
			
					if(m_enableNotifyCallFromStub && !m_internalUse)
					{
						::Proud::String parameterString;
						
						::Proud::AppendTextOut(parameterString,memberHostID);	
										
						parameterString += _PNT(", ");
						::Proud::AppendTextOut(parameterString,groupHostID);	
						
						NotifyCallFromStub(remote, (::Proud::RmiID)Rmi_P2PGroup_MemberLeave, 
							RmiName_P2PGroup_MemberLeave,parameterString);
			
			#ifdef VIZAGENT
						m_core->Viz_NotifyRecvToStub(remote, (::Proud::RmiID)Rmi_P2PGroup_MemberLeave, 
							RmiName_P2PGroup_MemberLeave, parameterString);
			#endif
					}
					else if(!m_internalUse)
					{
			#ifdef VIZAGENT
						m_core->Viz_NotifyRecvToStub(remote, (::Proud::RmiID)Rmi_P2PGroup_MemberLeave, 
							RmiName_P2PGroup_MemberLeave, _PNT(""));
			#endif
					}
						
					int64_t __t0 = 0;
					if(!m_internalUse)
					{
						if(m_enableStubProfiling)
						{
							::Proud::BeforeRmiSummary __summary;
							__summary.m_rmiID = (::Proud::RmiID)Rmi_P2PGroup_MemberLeave;
							__summary.m_rmiName = RmiName_P2PGroup_MemberLeave;
							__summary.m_hostID = remote;
							__summary.m_hostTag = hostTag;
							BeforeRmiInvocation(__summary);
							__t0 = ::Proud::GetPreciseCurrentTimeMs();
						}
					}
						
					// Call this method.
					bool __ret = P2PGroup_MemberLeave (remote,ctx , memberHostID, groupHostID );
						
					if(__ret==false)
					{
						// Error: RMI function that a user did not create has been called. 
						m_core->ShowNotImplementedRmiWarning(RmiName_P2PGroup_MemberLeave);
					}
			
					int64_t __t1;
			
					if(!m_internalUse && m_enableStubProfiling)
					{
						__t1 = ::Proud::GetPreciseCurrentTimeMs() - __t0;
			
						::Proud::AfterRmiSummary __summary;
						__summary.m_rmiID = (::Proud::RmiID)Rmi_P2PGroup_MemberLeave;
						__summary.m_rmiName = RmiName_P2PGroup_MemberLeave;
						__summary.m_hostID = remote;
						__summary.m_hostTag = hostTag;
			
						__summary.m_elapsedTime = (uint32_t)__t1;
			
						AfterRmiInvocation(__summary);
					}
				}
				break;
			case Rmi_NotifyDirectP2PEstablish:
				{
					::Proud::RmiContext ctx;
					ctx.m_rmiID = __rmiID;
					ctx.m_sentFrom=pa.GetRemoteHostID();
					ctx.m_relayed=pa.IsRelayed();
					ctx.m_hostTag = hostTag;
					ctx.m_encryptMode = pa.GetEncryptMode();
					ctx.m_compressMode = pa.GetCompressMode();
			
			        if(BeforeDeserialize(remote, ctx, __msg) == false)
			        {
			            // The user don't want to call the RMI function. 
						// So, We fake that it has been already called.
						__msg.SetReadOffset(__msg.GetLength());
			            return true;
			        }
			
					HostID aPeer; __msg >> aPeer;
					HostID bPeer; __msg >> bPeer;
					AddrPort X0; __msg >> X0;
					AddrPort Y0; __msg >> Y0;
					AddrPort Z0; __msg >> Z0;
					AddrPort W0; __msg >> W0;
					m_core->PostCheckReadMessage(__msg,RmiName_NotifyDirectP2PEstablish);
					
			
					if(m_enableNotifyCallFromStub && !m_internalUse)
					{
						::Proud::String parameterString;
						
						::Proud::AppendTextOut(parameterString,aPeer);	
										
						parameterString += _PNT(", ");
						::Proud::AppendTextOut(parameterString,bPeer);	
										
						parameterString += _PNT(", ");
						::Proud::AppendTextOut(parameterString,X0);	
										
						parameterString += _PNT(", ");
						::Proud::AppendTextOut(parameterString,Y0);	
										
						parameterString += _PNT(", ");
						::Proud::AppendTextOut(parameterString,Z0);	
										
						parameterString += _PNT(", ");
						::Proud::AppendTextOut(parameterString,W0);	
						
						NotifyCallFromStub(remote, (::Proud::RmiID)Rmi_NotifyDirectP2PEstablish, 
							RmiName_NotifyDirectP2PEstablish,parameterString);
			
			#ifdef VIZAGENT
						m_core->Viz_NotifyRecvToStub(remote, (::Proud::RmiID)Rmi_NotifyDirectP2PEstablish, 
							RmiName_NotifyDirectP2PEstablish, parameterString);
			#endif
					}
					else if(!m_internalUse)
					{
			#ifdef VIZAGENT
						m_core->Viz_NotifyRecvToStub(remote, (::Proud::RmiID)Rmi_NotifyDirectP2PEstablish, 
							RmiName_NotifyDirectP2PEstablish, _PNT(""));
			#endif
					}
						
					int64_t __t0 = 0;
					if(!m_internalUse)
					{
						if(m_enableStubProfiling)
						{
							::Proud::BeforeRmiSummary __summary;
							__summary.m_rmiID = (::Proud::RmiID)Rmi_NotifyDirectP2PEstablish;
							__summary.m_rmiName = RmiName_NotifyDirectP2PEstablish;
							__summary.m_hostID = remote;
							__summary.m_hostTag = hostTag;
							BeforeRmiInvocation(__summary);
							__t0 = ::Proud::GetPreciseCurrentTimeMs();
						}
					}
						
					// Call this method.
					bool __ret = NotifyDirectP2PEstablish (remote,ctx , aPeer, bPeer, X0, Y0, Z0, W0 );
						
					if(__ret==false)
					{
						// Error: RMI function that a user did not create has been called. 
						m_core->ShowNotImplementedRmiWarning(RmiName_NotifyDirectP2PEstablish);
					}
			
					int64_t __t1;
			
					if(!m_internalUse && m_enableStubProfiling)
					{
						__t1 = ::Proud::GetPreciseCurrentTimeMs() - __t0;
			
						::Proud::AfterRmiSummary __summary;
						__summary.m_rmiID = (::Proud::RmiID)Rmi_NotifyDirectP2PEstablish;
						__summary.m_rmiName = RmiName_NotifyDirectP2PEstablish;
						__summary.m_hostID = remote;
						__summary.m_hostTag = hostTag;
			
						__summary.m_elapsedTime = (uint32_t)__t1;
			
						AfterRmiInvocation(__summary);
					}
				}
				break;
			case Rmi_ReliablePong:
				{
					::Proud::RmiContext ctx;
					ctx.m_rmiID = __rmiID;
					ctx.m_sentFrom=pa.GetRemoteHostID();
					ctx.m_relayed=pa.IsRelayed();
					ctx.m_hostTag = hostTag;
					ctx.m_encryptMode = pa.GetEncryptMode();
					ctx.m_compressMode = pa.GetCompressMode();
			
			        if(BeforeDeserialize(remote, ctx, __msg) == false)
			        {
			            // The user don't want to call the RMI function. 
						// So, We fake that it has been already called.
						__msg.SetReadOffset(__msg.GetLength());
			            return true;
			        }
			
					int localTimeMs; __msg >> localTimeMs;
					int messageID; __msg >> messageID;
					m_core->PostCheckReadMessage(__msg,RmiName_ReliablePong);
					
			
					if(m_enableNotifyCallFromStub && !m_internalUse)
					{
						::Proud::String parameterString;
						
						::Proud::AppendTextOut(parameterString,localTimeMs);	
										
						parameterString += _PNT(", ");
						::Proud::AppendTextOut(parameterString,messageID);	
						
						NotifyCallFromStub(remote, (::Proud::RmiID)Rmi_ReliablePong, 
							RmiName_ReliablePong,parameterString);
			
			#ifdef VIZAGENT
						m_core->Viz_NotifyRecvToStub(remote, (::Proud::RmiID)Rmi_ReliablePong, 
							RmiName_ReliablePong, parameterString);
			#endif
					}
					else if(!m_internalUse)
					{
			#ifdef VIZAGENT
						m_core->Viz_NotifyRecvToStub(remote, (::Proud::RmiID)Rmi_ReliablePong, 
							RmiName_ReliablePong, _PNT(""));
			#endif
					}
						
					int64_t __t0 = 0;
					if(!m_internalUse)
					{
						if(m_enableStubProfiling)
						{
							::Proud::BeforeRmiSummary __summary;
							__summary.m_rmiID = (::Proud::RmiID)Rmi_ReliablePong;
							__summary.m_rmiName = RmiName_ReliablePong;
							__summary.m_hostID = remote;
							__summary.m_hostTag = hostTag;
							BeforeRmiInvocation(__summary);
							__t0 = ::Proud::GetPreciseCurrentTimeMs();
						}
					}
						
					// Call this method.
					bool __ret = ReliablePong (remote,ctx , localTimeMs, messageID );
						
					if(__ret==false)
					{
						// Error: RMI function that a user did not create has been called. 
						m_core->ShowNotImplementedRmiWarning(RmiName_ReliablePong);
					}
			
					int64_t __t1;
			
					if(!m_internalUse && m_enableStubProfiling)
					{
						__t1 = ::Proud::GetPreciseCurrentTimeMs() - __t0;
			
						::Proud::AfterRmiSummary __summary;
						__summary.m_rmiID = (::Proud::RmiID)Rmi_ReliablePong;
						__summary.m_rmiName = RmiName_ReliablePong;
						__summary.m_hostID = remote;
						__summary.m_hostTag = hostTag;
			
						__summary.m_elapsedTime = (uint32_t)__t1;
			
						AfterRmiInvocation(__summary);
					}
				}
				break;
			case Rmi_EnableLog:
				{
					::Proud::RmiContext ctx;
					ctx.m_rmiID = __rmiID;
					ctx.m_sentFrom=pa.GetRemoteHostID();
					ctx.m_relayed=pa.IsRelayed();
					ctx.m_hostTag = hostTag;
					ctx.m_encryptMode = pa.GetEncryptMode();
					ctx.m_compressMode = pa.GetCompressMode();
			
			        if(BeforeDeserialize(remote, ctx, __msg) == false)
			        {
			            // The user don't want to call the RMI function. 
						// So, We fake that it has been already called.
						__msg.SetReadOffset(__msg.GetLength());
			            return true;
			        }
			
					m_core->PostCheckReadMessage(__msg,RmiName_EnableLog);
					
			
					if(m_enableNotifyCallFromStub && !m_internalUse)
					{
						::Proud::String parameterString;
						
									
						NotifyCallFromStub(remote, (::Proud::RmiID)Rmi_EnableLog, 
							RmiName_EnableLog,parameterString);
			
			#ifdef VIZAGENT
						m_core->Viz_NotifyRecvToStub(remote, (::Proud::RmiID)Rmi_EnableLog, 
							RmiName_EnableLog, parameterString);
			#endif
					}
					else if(!m_internalUse)
					{
			#ifdef VIZAGENT
						m_core->Viz_NotifyRecvToStub(remote, (::Proud::RmiID)Rmi_EnableLog, 
							RmiName_EnableLog, _PNT(""));
			#endif
					}
						
					int64_t __t0 = 0;
					if(!m_internalUse)
					{
						if(m_enableStubProfiling)
						{
							::Proud::BeforeRmiSummary __summary;
							__summary.m_rmiID = (::Proud::RmiID)Rmi_EnableLog;
							__summary.m_rmiName = RmiName_EnableLog;
							__summary.m_hostID = remote;
							__summary.m_hostTag = hostTag;
							BeforeRmiInvocation(__summary);
							__t0 = ::Proud::GetPreciseCurrentTimeMs();
						}
					}
						
					// Call this method.
					bool __ret = EnableLog (remote,ctx  );
						
					if(__ret==false)
					{
						// Error: RMI function that a user did not create has been called. 
						m_core->ShowNotImplementedRmiWarning(RmiName_EnableLog);
					}
			
					int64_t __t1;
			
					if(!m_internalUse && m_enableStubProfiling)
					{
						__t1 = ::Proud::GetPreciseCurrentTimeMs() - __t0;
			
						::Proud::AfterRmiSummary __summary;
						__summary.m_rmiID = (::Proud::RmiID)Rmi_EnableLog;
						__summary.m_rmiName = RmiName_EnableLog;
						__summary.m_hostID = remote;
						__summary.m_hostTag = hostTag;
			
						__summary.m_elapsedTime = (uint32_t)__t1;
			
						AfterRmiInvocation(__summary);
					}
				}
				break;
			case Rmi_DisableLog:
				{
					::Proud::RmiContext ctx;
					ctx.m_rmiID = __rmiID;
					ctx.m_sentFrom=pa.GetRemoteHostID();
					ctx.m_relayed=pa.IsRelayed();
					ctx.m_hostTag = hostTag;
					ctx.m_encryptMode = pa.GetEncryptMode();
					ctx.m_compressMode = pa.GetCompressMode();
			
			        if(BeforeDeserialize(remote, ctx, __msg) == false)
			        {
			            // The user don't want to call the RMI function. 
						// So, We fake that it has been already called.
						__msg.SetReadOffset(__msg.GetLength());
			            return true;
			        }
			
					m_core->PostCheckReadMessage(__msg,RmiName_DisableLog);
					
			
					if(m_enableNotifyCallFromStub && !m_internalUse)
					{
						::Proud::String parameterString;
						
									
						NotifyCallFromStub(remote, (::Proud::RmiID)Rmi_DisableLog, 
							RmiName_DisableLog,parameterString);
			
			#ifdef VIZAGENT
						m_core->Viz_NotifyRecvToStub(remote, (::Proud::RmiID)Rmi_DisableLog, 
							RmiName_DisableLog, parameterString);
			#endif
					}
					else if(!m_internalUse)
					{
			#ifdef VIZAGENT
						m_core->Viz_NotifyRecvToStub(remote, (::Proud::RmiID)Rmi_DisableLog, 
							RmiName_DisableLog, _PNT(""));
			#endif
					}
						
					int64_t __t0 = 0;
					if(!m_internalUse)
					{
						if(m_enableStubProfiling)
						{
							::Proud::BeforeRmiSummary __summary;
							__summary.m_rmiID = (::Proud::RmiID)Rmi_DisableLog;
							__summary.m_rmiName = RmiName_DisableLog;
							__summary.m_hostID = remote;
							__summary.m_hostTag = hostTag;
							BeforeRmiInvocation(__summary);
							__t0 = ::Proud::GetPreciseCurrentTimeMs();
						}
					}
						
					// Call this method.
					bool __ret = DisableLog (remote,ctx  );
						
					if(__ret==false)
					{
						// Error: RMI function that a user did not create has been called. 
						m_core->ShowNotImplementedRmiWarning(RmiName_DisableLog);
					}
			
					int64_t __t1;
			
					if(!m_internalUse && m_enableStubProfiling)
					{
						__t1 = ::Proud::GetPreciseCurrentTimeMs() - __t0;
			
						::Proud::AfterRmiSummary __summary;
						__summary.m_rmiID = (::Proud::RmiID)Rmi_DisableLog;
						__summary.m_rmiName = RmiName_DisableLog;
						__summary.m_hostID = remote;
						__summary.m_hostTag = hostTag;
			
						__summary.m_elapsedTime = (uint32_t)__t1;
			
						AfterRmiInvocation(__summary);
					}
				}
				break;
			case Rmi_NotifyUdpToTcpFallbackByServer:
				{
					::Proud::RmiContext ctx;
					ctx.m_rmiID = __rmiID;
					ctx.m_sentFrom=pa.GetRemoteHostID();
					ctx.m_relayed=pa.IsRelayed();
					ctx.m_hostTag = hostTag;
					ctx.m_encryptMode = pa.GetEncryptMode();
					ctx.m_compressMode = pa.GetCompressMode();
			
			        if(BeforeDeserialize(remote, ctx, __msg) == false)
			        {
			            // The user don't want to call the RMI function. 
						// So, We fake that it has been already called.
						__msg.SetReadOffset(__msg.GetLength());
			            return true;
			        }
			
					m_core->PostCheckReadMessage(__msg,RmiName_NotifyUdpToTcpFallbackByServer);
					
			
					if(m_enableNotifyCallFromStub && !m_internalUse)
					{
						::Proud::String parameterString;
						
									
						NotifyCallFromStub(remote, (::Proud::RmiID)Rmi_NotifyUdpToTcpFallbackByServer, 
							RmiName_NotifyUdpToTcpFallbackByServer,parameterString);
			
			#ifdef VIZAGENT
						m_core->Viz_NotifyRecvToStub(remote, (::Proud::RmiID)Rmi_NotifyUdpToTcpFallbackByServer, 
							RmiName_NotifyUdpToTcpFallbackByServer, parameterString);
			#endif
					}
					else if(!m_internalUse)
					{
			#ifdef VIZAGENT
						m_core->Viz_NotifyRecvToStub(remote, (::Proud::RmiID)Rmi_NotifyUdpToTcpFallbackByServer, 
							RmiName_NotifyUdpToTcpFallbackByServer, _PNT(""));
			#endif
					}
						
					int64_t __t0 = 0;
					if(!m_internalUse)
					{
						if(m_enableStubProfiling)
						{
							::Proud::BeforeRmiSummary __summary;
							__summary.m_rmiID = (::Proud::RmiID)Rmi_NotifyUdpToTcpFallbackByServer;
							__summary.m_rmiName = RmiName_NotifyUdpToTcpFallbackByServer;
							__summary.m_hostID = remote;
							__summary.m_hostTag = hostTag;
							BeforeRmiInvocation(__summary);
							__t0 = ::Proud::GetPreciseCurrentTimeMs();
						}
					}
						
					// Call this method.
					bool __ret = NotifyUdpToTcpFallbackByServer (remote,ctx  );
						
					if(__ret==false)
					{
						// Error: RMI function that a user did not create has been called. 
						m_core->ShowNotImplementedRmiWarning(RmiName_NotifyUdpToTcpFallbackByServer);
					}
			
					int64_t __t1;
			
					if(!m_internalUse && m_enableStubProfiling)
					{
						__t1 = ::Proud::GetPreciseCurrentTimeMs() - __t0;
			
						::Proud::AfterRmiSummary __summary;
						__summary.m_rmiID = (::Proud::RmiID)Rmi_NotifyUdpToTcpFallbackByServer;
						__summary.m_rmiName = RmiName_NotifyUdpToTcpFallbackByServer;
						__summary.m_hostID = remote;
						__summary.m_hostTag = hostTag;
			
						__summary.m_elapsedTime = (uint32_t)__t1;
			
						AfterRmiInvocation(__summary);
					}
				}
				break;
			case Rmi_NotifySpeedHackDetectorEnabled:
				{
					::Proud::RmiContext ctx;
					ctx.m_rmiID = __rmiID;
					ctx.m_sentFrom=pa.GetRemoteHostID();
					ctx.m_relayed=pa.IsRelayed();
					ctx.m_hostTag = hostTag;
					ctx.m_encryptMode = pa.GetEncryptMode();
					ctx.m_compressMode = pa.GetCompressMode();
			
			        if(BeforeDeserialize(remote, ctx, __msg) == false)
			        {
			            // The user don't want to call the RMI function. 
						// So, We fake that it has been already called.
						__msg.SetReadOffset(__msg.GetLength());
			            return true;
			        }
			
					bool enable; __msg >> enable;
					m_core->PostCheckReadMessage(__msg,RmiName_NotifySpeedHackDetectorEnabled);
					
			
					if(m_enableNotifyCallFromStub && !m_internalUse)
					{
						::Proud::String parameterString;
						
						::Proud::AppendTextOut(parameterString,enable);	
						
						NotifyCallFromStub(remote, (::Proud::RmiID)Rmi_NotifySpeedHackDetectorEnabled, 
							RmiName_NotifySpeedHackDetectorEnabled,parameterString);
			
			#ifdef VIZAGENT
						m_core->Viz_NotifyRecvToStub(remote, (::Proud::RmiID)Rmi_NotifySpeedHackDetectorEnabled, 
							RmiName_NotifySpeedHackDetectorEnabled, parameterString);
			#endif
					}
					else if(!m_internalUse)
					{
			#ifdef VIZAGENT
						m_core->Viz_NotifyRecvToStub(remote, (::Proud::RmiID)Rmi_NotifySpeedHackDetectorEnabled, 
							RmiName_NotifySpeedHackDetectorEnabled, _PNT(""));
			#endif
					}
						
					int64_t __t0 = 0;
					if(!m_internalUse)
					{
						if(m_enableStubProfiling)
						{
							::Proud::BeforeRmiSummary __summary;
							__summary.m_rmiID = (::Proud::RmiID)Rmi_NotifySpeedHackDetectorEnabled;
							__summary.m_rmiName = RmiName_NotifySpeedHackDetectorEnabled;
							__summary.m_hostID = remote;
							__summary.m_hostTag = hostTag;
							BeforeRmiInvocation(__summary);
							__t0 = ::Proud::GetPreciseCurrentTimeMs();
						}
					}
						
					// Call this method.
					bool __ret = NotifySpeedHackDetectorEnabled (remote,ctx , enable );
						
					if(__ret==false)
					{
						// Error: RMI function that a user did not create has been called. 
						m_core->ShowNotImplementedRmiWarning(RmiName_NotifySpeedHackDetectorEnabled);
					}
			
					int64_t __t1;
			
					if(!m_internalUse && m_enableStubProfiling)
					{
						__t1 = ::Proud::GetPreciseCurrentTimeMs() - __t0;
			
						::Proud::AfterRmiSummary __summary;
						__summary.m_rmiID = (::Proud::RmiID)Rmi_NotifySpeedHackDetectorEnabled;
						__summary.m_rmiName = RmiName_NotifySpeedHackDetectorEnabled;
						__summary.m_hostID = remote;
						__summary.m_hostTag = hostTag;
			
						__summary.m_elapsedTime = (uint32_t)__t1;
			
						AfterRmiInvocation(__summary);
					}
				}
				break;
			case Rmi_ShutdownTcpAck:
				{
					::Proud::RmiContext ctx;
					ctx.m_rmiID = __rmiID;
					ctx.m_sentFrom=pa.GetRemoteHostID();
					ctx.m_relayed=pa.IsRelayed();
					ctx.m_hostTag = hostTag;
					ctx.m_encryptMode = pa.GetEncryptMode();
					ctx.m_compressMode = pa.GetCompressMode();
			
			        if(BeforeDeserialize(remote, ctx, __msg) == false)
			        {
			            // The user don't want to call the RMI function. 
						// So, We fake that it has been already called.
						__msg.SetReadOffset(__msg.GetLength());
			            return true;
			        }
			
					m_core->PostCheckReadMessage(__msg,RmiName_ShutdownTcpAck);
					
			
					if(m_enableNotifyCallFromStub && !m_internalUse)
					{
						::Proud::String parameterString;
						
									
						NotifyCallFromStub(remote, (::Proud::RmiID)Rmi_ShutdownTcpAck, 
							RmiName_ShutdownTcpAck,parameterString);
			
			#ifdef VIZAGENT
						m_core->Viz_NotifyRecvToStub(remote, (::Proud::RmiID)Rmi_ShutdownTcpAck, 
							RmiName_ShutdownTcpAck, parameterString);
			#endif
					}
					else if(!m_internalUse)
					{
			#ifdef VIZAGENT
						m_core->Viz_NotifyRecvToStub(remote, (::Proud::RmiID)Rmi_ShutdownTcpAck, 
							RmiName_ShutdownTcpAck, _PNT(""));
			#endif
					}
						
					int64_t __t0 = 0;
					if(!m_internalUse)
					{
						if(m_enableStubProfiling)
						{
							::Proud::BeforeRmiSummary __summary;
							__summary.m_rmiID = (::Proud::RmiID)Rmi_ShutdownTcpAck;
							__summary.m_rmiName = RmiName_ShutdownTcpAck;
							__summary.m_hostID = remote;
							__summary.m_hostTag = hostTag;
							BeforeRmiInvocation(__summary);
							__t0 = ::Proud::GetPreciseCurrentTimeMs();
						}
					}
						
					// Call this method.
					bool __ret = ShutdownTcpAck (remote,ctx  );
						
					if(__ret==false)
					{
						// Error: RMI function that a user did not create has been called. 
						m_core->ShowNotImplementedRmiWarning(RmiName_ShutdownTcpAck);
					}
			
					int64_t __t1;
			
					if(!m_internalUse && m_enableStubProfiling)
					{
						__t1 = ::Proud::GetPreciseCurrentTimeMs() - __t0;
			
						::Proud::AfterRmiSummary __summary;
						__summary.m_rmiID = (::Proud::RmiID)Rmi_ShutdownTcpAck;
						__summary.m_rmiName = RmiName_ShutdownTcpAck;
						__summary.m_hostID = remote;
						__summary.m_hostTag = hostTag;
			
						__summary.m_elapsedTime = (uint32_t)__t1;
			
						AfterRmiInvocation(__summary);
					}
				}
				break;
			case Rmi_RequestAutoPrune:
				{
					::Proud::RmiContext ctx;
					ctx.m_rmiID = __rmiID;
					ctx.m_sentFrom=pa.GetRemoteHostID();
					ctx.m_relayed=pa.IsRelayed();
					ctx.m_hostTag = hostTag;
					ctx.m_encryptMode = pa.GetEncryptMode();
					ctx.m_compressMode = pa.GetCompressMode();
			
			        if(BeforeDeserialize(remote, ctx, __msg) == false)
			        {
			            // The user don't want to call the RMI function. 
						// So, We fake that it has been already called.
						__msg.SetReadOffset(__msg.GetLength());
			            return true;
			        }
			
					m_core->PostCheckReadMessage(__msg,RmiName_RequestAutoPrune);
					
			
					if(m_enableNotifyCallFromStub && !m_internalUse)
					{
						::Proud::String parameterString;
						
									
						NotifyCallFromStub(remote, (::Proud::RmiID)Rmi_RequestAutoPrune, 
							RmiName_RequestAutoPrune,parameterString);
			
			#ifdef VIZAGENT
						m_core->Viz_NotifyRecvToStub(remote, (::Proud::RmiID)Rmi_RequestAutoPrune, 
							RmiName_RequestAutoPrune, parameterString);
			#endif
					}
					else if(!m_internalUse)
					{
			#ifdef VIZAGENT
						m_core->Viz_NotifyRecvToStub(remote, (::Proud::RmiID)Rmi_RequestAutoPrune, 
							RmiName_RequestAutoPrune, _PNT(""));
			#endif
					}
						
					int64_t __t0 = 0;
					if(!m_internalUse)
					{
						if(m_enableStubProfiling)
						{
							::Proud::BeforeRmiSummary __summary;
							__summary.m_rmiID = (::Proud::RmiID)Rmi_RequestAutoPrune;
							__summary.m_rmiName = RmiName_RequestAutoPrune;
							__summary.m_hostID = remote;
							__summary.m_hostTag = hostTag;
							BeforeRmiInvocation(__summary);
							__t0 = ::Proud::GetPreciseCurrentTimeMs();
						}
					}
						
					// Call this method.
					bool __ret = RequestAutoPrune (remote,ctx  );
						
					if(__ret==false)
					{
						// Error: RMI function that a user did not create has been called. 
						m_core->ShowNotImplementedRmiWarning(RmiName_RequestAutoPrune);
					}
			
					int64_t __t1;
			
					if(!m_internalUse && m_enableStubProfiling)
					{
						__t1 = ::Proud::GetPreciseCurrentTimeMs() - __t0;
			
						::Proud::AfterRmiSummary __summary;
						__summary.m_rmiID = (::Proud::RmiID)Rmi_RequestAutoPrune;
						__summary.m_rmiName = RmiName_RequestAutoPrune;
						__summary.m_hostID = remote;
						__summary.m_hostTag = hostTag;
			
						__summary.m_elapsedTime = (uint32_t)__t1;
			
						AfterRmiInvocation(__summary);
					}
				}
				break;
			case Rmi_NewDirectP2PConnection:
				{
					::Proud::RmiContext ctx;
					ctx.m_rmiID = __rmiID;
					ctx.m_sentFrom=pa.GetRemoteHostID();
					ctx.m_relayed=pa.IsRelayed();
					ctx.m_hostTag = hostTag;
					ctx.m_encryptMode = pa.GetEncryptMode();
					ctx.m_compressMode = pa.GetCompressMode();
			
			        if(BeforeDeserialize(remote, ctx, __msg) == false)
			        {
			            // The user don't want to call the RMI function. 
						// So, We fake that it has been already called.
						__msg.SetReadOffset(__msg.GetLength());
			            return true;
			        }
			
					HostID remotePeerID; __msg >> remotePeerID;
					m_core->PostCheckReadMessage(__msg,RmiName_NewDirectP2PConnection);
					
			
					if(m_enableNotifyCallFromStub && !m_internalUse)
					{
						::Proud::String parameterString;
						
						::Proud::AppendTextOut(parameterString,remotePeerID);	
						
						NotifyCallFromStub(remote, (::Proud::RmiID)Rmi_NewDirectP2PConnection, 
							RmiName_NewDirectP2PConnection,parameterString);
			
			#ifdef VIZAGENT
						m_core->Viz_NotifyRecvToStub(remote, (::Proud::RmiID)Rmi_NewDirectP2PConnection, 
							RmiName_NewDirectP2PConnection, parameterString);
			#endif
					}
					else if(!m_internalUse)
					{
			#ifdef VIZAGENT
						m_core->Viz_NotifyRecvToStub(remote, (::Proud::RmiID)Rmi_NewDirectP2PConnection, 
							RmiName_NewDirectP2PConnection, _PNT(""));
			#endif
					}
						
					int64_t __t0 = 0;
					if(!m_internalUse)
					{
						if(m_enableStubProfiling)
						{
							::Proud::BeforeRmiSummary __summary;
							__summary.m_rmiID = (::Proud::RmiID)Rmi_NewDirectP2PConnection;
							__summary.m_rmiName = RmiName_NewDirectP2PConnection;
							__summary.m_hostID = remote;
							__summary.m_hostTag = hostTag;
							BeforeRmiInvocation(__summary);
							__t0 = ::Proud::GetPreciseCurrentTimeMs();
						}
					}
						
					// Call this method.
					bool __ret = NewDirectP2PConnection (remote,ctx , remotePeerID );
						
					if(__ret==false)
					{
						// Error: RMI function that a user did not create has been called. 
						m_core->ShowNotImplementedRmiWarning(RmiName_NewDirectP2PConnection);
					}
			
					int64_t __t1;
			
					if(!m_internalUse && m_enableStubProfiling)
					{
						__t1 = ::Proud::GetPreciseCurrentTimeMs() - __t0;
			
						::Proud::AfterRmiSummary __summary;
						__summary.m_rmiID = (::Proud::RmiID)Rmi_NewDirectP2PConnection;
						__summary.m_rmiName = RmiName_NewDirectP2PConnection;
						__summary.m_hostID = remote;
						__summary.m_hostTag = hostTag;
			
						__summary.m_elapsedTime = (uint32_t)__t1;
			
						AfterRmiInvocation(__summary);
					}
				}
				break;
			case Rmi_RequestMeasureSendSpeed:
				{
					::Proud::RmiContext ctx;
					ctx.m_rmiID = __rmiID;
					ctx.m_sentFrom=pa.GetRemoteHostID();
					ctx.m_relayed=pa.IsRelayed();
					ctx.m_hostTag = hostTag;
					ctx.m_encryptMode = pa.GetEncryptMode();
					ctx.m_compressMode = pa.GetCompressMode();
			
			        if(BeforeDeserialize(remote, ctx, __msg) == false)
			        {
			            // The user don't want to call the RMI function. 
						// So, We fake that it has been already called.
						__msg.SetReadOffset(__msg.GetLength());
			            return true;
			        }
			
					bool enable; __msg >> enable;
					m_core->PostCheckReadMessage(__msg,RmiName_RequestMeasureSendSpeed);
					
			
					if(m_enableNotifyCallFromStub && !m_internalUse)
					{
						::Proud::String parameterString;
						
						::Proud::AppendTextOut(parameterString,enable);	
						
						NotifyCallFromStub(remote, (::Proud::RmiID)Rmi_RequestMeasureSendSpeed, 
							RmiName_RequestMeasureSendSpeed,parameterString);
			
			#ifdef VIZAGENT
						m_core->Viz_NotifyRecvToStub(remote, (::Proud::RmiID)Rmi_RequestMeasureSendSpeed, 
							RmiName_RequestMeasureSendSpeed, parameterString);
			#endif
					}
					else if(!m_internalUse)
					{
			#ifdef VIZAGENT
						m_core->Viz_NotifyRecvToStub(remote, (::Proud::RmiID)Rmi_RequestMeasureSendSpeed, 
							RmiName_RequestMeasureSendSpeed, _PNT(""));
			#endif
					}
						
					int64_t __t0 = 0;
					if(!m_internalUse)
					{
						if(m_enableStubProfiling)
						{
							::Proud::BeforeRmiSummary __summary;
							__summary.m_rmiID = (::Proud::RmiID)Rmi_RequestMeasureSendSpeed;
							__summary.m_rmiName = RmiName_RequestMeasureSendSpeed;
							__summary.m_hostID = remote;
							__summary.m_hostTag = hostTag;
							BeforeRmiInvocation(__summary);
							__t0 = ::Proud::GetPreciseCurrentTimeMs();
						}
					}
						
					// Call this method.
					bool __ret = RequestMeasureSendSpeed (remote,ctx , enable );
						
					if(__ret==false)
					{
						// Error: RMI function that a user did not create has been called. 
						m_core->ShowNotImplementedRmiWarning(RmiName_RequestMeasureSendSpeed);
					}
			
					int64_t __t1;
			
					if(!m_internalUse && m_enableStubProfiling)
					{
						__t1 = ::Proud::GetPreciseCurrentTimeMs() - __t0;
			
						::Proud::AfterRmiSummary __summary;
						__summary.m_rmiID = (::Proud::RmiID)Rmi_RequestMeasureSendSpeed;
						__summary.m_rmiName = RmiName_RequestMeasureSendSpeed;
						__summary.m_hostID = remote;
						__summary.m_hostTag = hostTag;
			
						__summary.m_elapsedTime = (uint32_t)__t1;
			
						AfterRmiInvocation(__summary);
					}
				}
				break;
			case Rmi_S2C_RequestCreateUdpSocket:
				{
					::Proud::RmiContext ctx;
					ctx.m_rmiID = __rmiID;
					ctx.m_sentFrom=pa.GetRemoteHostID();
					ctx.m_relayed=pa.IsRelayed();
					ctx.m_hostTag = hostTag;
					ctx.m_encryptMode = pa.GetEncryptMode();
					ctx.m_compressMode = pa.GetCompressMode();
			
			        if(BeforeDeserialize(remote, ctx, __msg) == false)
			        {
			            // The user don't want to call the RMI function. 
						// So, We fake that it has been already called.
						__msg.SetReadOffset(__msg.GetLength());
			            return true;
			        }
			
					NamedAddrPort serverUdpAddr; __msg >> serverUdpAddr;
					m_core->PostCheckReadMessage(__msg,RmiName_S2C_RequestCreateUdpSocket);
					
			
					if(m_enableNotifyCallFromStub && !m_internalUse)
					{
						::Proud::String parameterString;
						
						::Proud::AppendTextOut(parameterString,serverUdpAddr);	
						
						NotifyCallFromStub(remote, (::Proud::RmiID)Rmi_S2C_RequestCreateUdpSocket, 
							RmiName_S2C_RequestCreateUdpSocket,parameterString);
			
			#ifdef VIZAGENT
						m_core->Viz_NotifyRecvToStub(remote, (::Proud::RmiID)Rmi_S2C_RequestCreateUdpSocket, 
							RmiName_S2C_RequestCreateUdpSocket, parameterString);
			#endif
					}
					else if(!m_internalUse)
					{
			#ifdef VIZAGENT
						m_core->Viz_NotifyRecvToStub(remote, (::Proud::RmiID)Rmi_S2C_RequestCreateUdpSocket, 
							RmiName_S2C_RequestCreateUdpSocket, _PNT(""));
			#endif
					}
						
					int64_t __t0 = 0;
					if(!m_internalUse)
					{
						if(m_enableStubProfiling)
						{
							::Proud::BeforeRmiSummary __summary;
							__summary.m_rmiID = (::Proud::RmiID)Rmi_S2C_RequestCreateUdpSocket;
							__summary.m_rmiName = RmiName_S2C_RequestCreateUdpSocket;
							__summary.m_hostID = remote;
							__summary.m_hostTag = hostTag;
							BeforeRmiInvocation(__summary);
							__t0 = ::Proud::GetPreciseCurrentTimeMs();
						}
					}
						
					// Call this method.
					bool __ret = S2C_RequestCreateUdpSocket (remote,ctx , serverUdpAddr );
						
					if(__ret==false)
					{
						// Error: RMI function that a user did not create has been called. 
						m_core->ShowNotImplementedRmiWarning(RmiName_S2C_RequestCreateUdpSocket);
					}
			
					int64_t __t1;
			
					if(!m_internalUse && m_enableStubProfiling)
					{
						__t1 = ::Proud::GetPreciseCurrentTimeMs() - __t0;
			
						::Proud::AfterRmiSummary __summary;
						__summary.m_rmiID = (::Proud::RmiID)Rmi_S2C_RequestCreateUdpSocket;
						__summary.m_rmiName = RmiName_S2C_RequestCreateUdpSocket;
						__summary.m_hostID = remote;
						__summary.m_hostTag = hostTag;
			
						__summary.m_elapsedTime = (uint32_t)__t1;
			
						AfterRmiInvocation(__summary);
					}
				}
				break;
			case Rmi_S2C_CreateUdpSocketAck:
				{
					::Proud::RmiContext ctx;
					ctx.m_rmiID = __rmiID;
					ctx.m_sentFrom=pa.GetRemoteHostID();
					ctx.m_relayed=pa.IsRelayed();
					ctx.m_hostTag = hostTag;
					ctx.m_encryptMode = pa.GetEncryptMode();
					ctx.m_compressMode = pa.GetCompressMode();
			
			        if(BeforeDeserialize(remote, ctx, __msg) == false)
			        {
			            // The user don't want to call the RMI function. 
						// So, We fake that it has been already called.
						__msg.SetReadOffset(__msg.GetLength());
			            return true;
			        }
			
					bool succeed; __msg >> succeed;
					NamedAddrPort serverudpaddr; __msg >> serverudpaddr;
					m_core->PostCheckReadMessage(__msg,RmiName_S2C_CreateUdpSocketAck);
					
			
					if(m_enableNotifyCallFromStub && !m_internalUse)
					{
						::Proud::String parameterString;
						
						::Proud::AppendTextOut(parameterString,succeed);	
										
						parameterString += _PNT(", ");
						::Proud::AppendTextOut(parameterString,serverudpaddr);	
						
						NotifyCallFromStub(remote, (::Proud::RmiID)Rmi_S2C_CreateUdpSocketAck, 
							RmiName_S2C_CreateUdpSocketAck,parameterString);
			
			#ifdef VIZAGENT
						m_core->Viz_NotifyRecvToStub(remote, (::Proud::RmiID)Rmi_S2C_CreateUdpSocketAck, 
							RmiName_S2C_CreateUdpSocketAck, parameterString);
			#endif
					}
					else if(!m_internalUse)
					{
			#ifdef VIZAGENT
						m_core->Viz_NotifyRecvToStub(remote, (::Proud::RmiID)Rmi_S2C_CreateUdpSocketAck, 
							RmiName_S2C_CreateUdpSocketAck, _PNT(""));
			#endif
					}
						
					int64_t __t0 = 0;
					if(!m_internalUse)
					{
						if(m_enableStubProfiling)
						{
							::Proud::BeforeRmiSummary __summary;
							__summary.m_rmiID = (::Proud::RmiID)Rmi_S2C_CreateUdpSocketAck;
							__summary.m_rmiName = RmiName_S2C_CreateUdpSocketAck;
							__summary.m_hostID = remote;
							__summary.m_hostTag = hostTag;
							BeforeRmiInvocation(__summary);
							__t0 = ::Proud::GetPreciseCurrentTimeMs();
						}
					}
						
					// Call this method.
					bool __ret = S2C_CreateUdpSocketAck (remote,ctx , succeed, serverudpaddr );
						
					if(__ret==false)
					{
						// Error: RMI function that a user did not create has been called. 
						m_core->ShowNotImplementedRmiWarning(RmiName_S2C_CreateUdpSocketAck);
					}
			
					int64_t __t1;
			
					if(!m_internalUse && m_enableStubProfiling)
					{
						__t1 = ::Proud::GetPreciseCurrentTimeMs() - __t0;
			
						::Proud::AfterRmiSummary __summary;
						__summary.m_rmiID = (::Proud::RmiID)Rmi_S2C_CreateUdpSocketAck;
						__summary.m_rmiName = RmiName_S2C_CreateUdpSocketAck;
						__summary.m_hostID = remote;
						__summary.m_hostTag = hostTag;
			
						__summary.m_elapsedTime = (uint32_t)__t1;
			
						AfterRmiInvocation(__summary);
					}
				}
				break;
		default:
			goto __fail;
		}		
		return true;
__fail:
		{
			__msg.SetReadOffset(orgReadOffset);
			return false;
		}
	}
	#ifdef USE_RMI_NAME_STRING
	const PNTCHAR* Stub::RmiName_P2PGroup_MemberJoin =_PNT("P2PGroup_MemberJoin");
	#else
	const PNTCHAR* Stub::RmiName_P2PGroup_MemberJoin =_PNT("");
	#endif
	#ifdef USE_RMI_NAME_STRING
	const PNTCHAR* Stub::RmiName_RequestP2PHolepunch =_PNT("RequestP2PHolepunch");
	#else
	const PNTCHAR* Stub::RmiName_RequestP2PHolepunch =_PNT("");
	#endif
	#ifdef USE_RMI_NAME_STRING
	const PNTCHAR* Stub::RmiName_P2P_NotifyDirectP2PDisconnected2 =_PNT("P2P_NotifyDirectP2PDisconnected2");
	#else
	const PNTCHAR* Stub::RmiName_P2P_NotifyDirectP2PDisconnected2 =_PNT("");
	#endif
	#ifdef USE_RMI_NAME_STRING
	const PNTCHAR* Stub::RmiName_P2P_NotifyP2PMemberOffline =_PNT("P2P_NotifyP2PMemberOffline");
	#else
	const PNTCHAR* Stub::RmiName_P2P_NotifyP2PMemberOffline =_PNT("");
	#endif
	#ifdef USE_RMI_NAME_STRING
	const PNTCHAR* Stub::RmiName_P2P_NotifyP2PMemberOnline =_PNT("P2P_NotifyP2PMemberOnline");
	#else
	const PNTCHAR* Stub::RmiName_P2P_NotifyP2PMemberOnline =_PNT("");
	#endif
	#ifdef USE_RMI_NAME_STRING
	const PNTCHAR* Stub::RmiName_P2PGroup_MemberLeave =_PNT("P2PGroup_MemberLeave");
	#else
	const PNTCHAR* Stub::RmiName_P2PGroup_MemberLeave =_PNT("");
	#endif
	#ifdef USE_RMI_NAME_STRING
	const PNTCHAR* Stub::RmiName_NotifyDirectP2PEstablish =_PNT("NotifyDirectP2PEstablish");
	#else
	const PNTCHAR* Stub::RmiName_NotifyDirectP2PEstablish =_PNT("");
	#endif
	#ifdef USE_RMI_NAME_STRING
	const PNTCHAR* Stub::RmiName_ReliablePong =_PNT("ReliablePong");
	#else
	const PNTCHAR* Stub::RmiName_ReliablePong =_PNT("");
	#endif
	#ifdef USE_RMI_NAME_STRING
	const PNTCHAR* Stub::RmiName_EnableLog =_PNT("EnableLog");
	#else
	const PNTCHAR* Stub::RmiName_EnableLog =_PNT("");
	#endif
	#ifdef USE_RMI_NAME_STRING
	const PNTCHAR* Stub::RmiName_DisableLog =_PNT("DisableLog");
	#else
	const PNTCHAR* Stub::RmiName_DisableLog =_PNT("");
	#endif
	#ifdef USE_RMI_NAME_STRING
	const PNTCHAR* Stub::RmiName_NotifyUdpToTcpFallbackByServer =_PNT("NotifyUdpToTcpFallbackByServer");
	#else
	const PNTCHAR* Stub::RmiName_NotifyUdpToTcpFallbackByServer =_PNT("");
	#endif
	#ifdef USE_RMI_NAME_STRING
	const PNTCHAR* Stub::RmiName_NotifySpeedHackDetectorEnabled =_PNT("NotifySpeedHackDetectorEnabled");
	#else
	const PNTCHAR* Stub::RmiName_NotifySpeedHackDetectorEnabled =_PNT("");
	#endif
	#ifdef USE_RMI_NAME_STRING
	const PNTCHAR* Stub::RmiName_ShutdownTcpAck =_PNT("ShutdownTcpAck");
	#else
	const PNTCHAR* Stub::RmiName_ShutdownTcpAck =_PNT("");
	#endif
	#ifdef USE_RMI_NAME_STRING
	const PNTCHAR* Stub::RmiName_RequestAutoPrune =_PNT("RequestAutoPrune");
	#else
	const PNTCHAR* Stub::RmiName_RequestAutoPrune =_PNT("");
	#endif
	#ifdef USE_RMI_NAME_STRING
	const PNTCHAR* Stub::RmiName_NewDirectP2PConnection =_PNT("NewDirectP2PConnection");
	#else
	const PNTCHAR* Stub::RmiName_NewDirectP2PConnection =_PNT("");
	#endif
	#ifdef USE_RMI_NAME_STRING
	const PNTCHAR* Stub::RmiName_RequestMeasureSendSpeed =_PNT("RequestMeasureSendSpeed");
	#else
	const PNTCHAR* Stub::RmiName_RequestMeasureSendSpeed =_PNT("");
	#endif
	#ifdef USE_RMI_NAME_STRING
	const PNTCHAR* Stub::RmiName_S2C_RequestCreateUdpSocket =_PNT("S2C_RequestCreateUdpSocket");
	#else
	const PNTCHAR* Stub::RmiName_S2C_RequestCreateUdpSocket =_PNT("");
	#endif
	#ifdef USE_RMI_NAME_STRING
	const PNTCHAR* Stub::RmiName_S2C_CreateUdpSocketAck =_PNT("S2C_CreateUdpSocketAck");
	#else
	const PNTCHAR* Stub::RmiName_S2C_CreateUdpSocketAck =_PNT("");
	#endif
	const PNTCHAR* Stub::RmiName_First = RmiName_P2PGroup_MemberJoin;

}



