<#@ template language="C#" #>
<#@ assembly name="System" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>

// Generated by PIDL compiler.
// Do not modify this file, but modify the source .pidl file.

#pragma once

<#foreach(var c in App.g_parsed.m_components) { #>

<#=c.GetNamespaceStartStatement()#>

	<#=c.GetClassNameOnly()#>::<#=c.GetClassNameOnly()#>()
	{
		// do nothing. Just for your easier debugging.
	}

	<#=c.GetClassNameOnly()#>::~<#=c.GetClassNameOnly()#>()
	{
		// do nothing. Just for your easier debugging.
	}

	const Guid <#=c.GetClassNameOnly()#>::TypeID(<#=c.GetTypeID()#>);

	void <#=c.GetClassNameOnly()#>::SerializeMembers(CMessage& __data)
	{
		__data << (int)<#=c.m_fields.Count#>;
<# foreach(var f in c.m_fields) { #>		
		__data << "<#=f.m_name#>"; // 필드이름
		__data << typeid(<#=f.m_name#>).name(); // 필드타입
		__data << <#=f.m_name#>; // 필드값
<# } #>
	}

	bool <#=c.GetClassNameOnly()#>::DeserializeMembers(CMessage& __data)
	{
		int __fieldCount;
		__data >> __fieldCount;

		std::string __fieldName;
		std::string __fieldType;

		for (int __i = 0; __i < __fieldCount; __i++)
		{
			__data >> __fieldName;
			__data >> __fieldType;

			if(0) {} // 의미없음
<# foreach(var f in c.m_fields) { #>		
			else if (__fieldName == "<#=f.m_name#>")
			{
				if (__fieldType != typeid(<#=f.m_name#>).name())
					return false;
				__data >> <#=f.m_name#>;
			}
<# } #>
		}

		return true;
	}

	void <#=c.GetClassNameOnly()#>::AppendChanged_FieldOnly(ComponentAsStringMap& __change_component, ComponentAsStringMap& __lastState_component)
	{
<#
		foreach(var f in c.m_fields){
		if(!f.m_attrList.m_attrMap.ContainsKey("DoNotMonitor")) {
#>
		UpdateChangedField(this, __change_component, __lastState_component, "<#=f.m_name#>", <#=f.m_name#>);
<#
		} else {
#>
		// Skipping the field '<#=f.m_name#>'...
<#
		} }
#>
	}

<#=c.GetNamespaceEndStatement()#>

<# } #>

<# if(App.g_parsed.m_module != null) { #>

class <#=App.g_parsed.m_module.m_name#>Util :public Proud::Retained::ServerDataUtil
{
public:
	~<#=App.g_parsed.m_module.m_name#>Util()
	{
		// do nothing
	}
	
	Proud::Retained::Component* CreateComponentByTypeName(const char* typeName) override;
	
};

Proud::Retained::Component* <#=App.g_parsed.m_module.m_name#>Util::CreateComponentByTypeName(const char* typeName)
{
<#foreach(var c in App.g_parsed.m_components) { #>
	if (!strcmp(typeName, "class <#=c.m_className#>" )) // type_info.name() 값
	{
		return new <#=c.m_className#>();
	}
<# } #>
	// 매치되는 것이 없다. 아마도 에러다.
	return nullptr;
}

<#=App.g_parsed.m_module.m_name#>Util g_serverDataUtil;

// LoadLibrary에서 사용되는 exported function이다.
Proud::Retained::ServerDataUtil* GetRetainedServerDataUtil()
{	
	return &g_serverDataUtil;
}

<# } #> 
