<#@ template language="C#" #>
<#@ assembly name="System" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ include file="CppHelper.ttinclude"#>
// Generated by PIDL compiler.
// Do not modify this file, but modify the source .pidl file.


#include "<#=App.m_StubHFileName#>"

<#
foreach(var inc in App.g_parsed.m_includes)
{
#>
#include <#=inc.m_name#>
<#
}#>

const unsigned char sz<#=App.GetVariablizedName(App.m_StubHFileName)#>Rmi[] =
{ 0x00, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xff, 0x00, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xff,
<#
    App.GenerateWatermarkByteArrayDefinition(App.g_licenseInfo.m_name);
    App.GenerateWatermarkByteArrayDefinition(App.g_licenseInfo.m_company);
#>
0xaa, 0xbb, 0xcc, 0xdd, 0xff,0x99, 0xaa, 0xbb, 0xcc, 0x99, 0xaa, 0xdd, 0xff, 0x00 };

<#
    foreach(var gi in App.g_parsed.m_globalInterfaces)
    {
#>

<#=gi.GetCppNestedNamespaceDefinition()#>

<#
        ProcessReceivedMessageDef(gi);

        PushIndent("\t");
        DefRmiNames_cpp("Stub",gi);
        PopIndent();

#>

<#=gi.GetCppNestedNamespaceDefinitionEnd()#>

<#
    } // for each gi
#>

<#+
    void ProcessReceivedMessageDef(Parsed_GlobalInterface gi)
    {
#>
    bool Stub::ProcessReceivedMessage(::Proud::CReceivedMessage &pa, void* hostTag)
    {
#ifndef __FreeBSD__
        {
            // unusable but required. you may ignore it, because it does not occur any worthless load.
            unsigned char x = sz<#=App.GetVariablizedName(App.m_StubHFileName)#>Rmi[0];
            x++;
        }
#endif
        ::Proud::HostID remote=pa.GetRemoteHostID();
        if(remote==::Proud::HostID_None)
        {
            ShowUnknownHostIDWarning(remote);
        }

        ::Proud::CMessage &__msg=pa.GetReadOnlyMessage();
        int orgReadOffset = __msg.GetReadOffset();

        ::Proud::RmiID __rmiID;
        if(!__msg.Read(__rmiID))
            goto __fail;

        switch((int)__rmiID) // case is to prevent from clang compile error
        {
<#+
    PushIndent("\t\t\t");
    foreach(var mt in gi.m_methods)
    {
        DoCasePerMethod("__msg",gi,mt);
    }
    PopIndent();
#>
        default:
            goto __fail;
        }
        return true;
__fail:
        {
            __msg.SetReadOffset(orgReadOffset);
            return false;
        }
    }
<#+
   } // ProcessReceivedMessageDef
#>

<#+
    void DoCasePerMethod(string msgVariableName, Parsed_GlobalInterface gi, Parsed_Method mt)
    {
#>
case Rmi_<#=mt.m_name#>:
    {
        ::Proud::RmiContext ctx;
        ctx.m_rmiID = __rmiID;
        ctx.m_sentFrom=pa.GetRemoteHostID();
        ctx.m_relayed=pa.IsRelayed();
        ctx.m_hostTag = hostTag;
        ctx.m_encryptMode = pa.GetEncryptMode();
        ctx.m_compressMode = pa.GetCompressMode();

        if(BeforeDeserialize(remote, ctx, __msg) == false)
        {
            // The user don't want to call the RMI function.
            // So, We fake that it has been already called.
            __msg.SetReadOffset(__msg.GetLength());
            return true;
        }

        <#+ PushIndent("\t\t");
        DeserializeParams(msgVariableName, gi,mt);
        PopIndent(); #>


        if(m_enableNotifyCallFromStub && !m_internalUse)
        {
            ::Proud::String parameterString;

            <#+ PushIndent("\t\t\t");
            MakeParameterText("parameterString", mt);
            PopIndent();#>

            NotifyCallFromStub(remote, (::Proud::RmiID)Rmi_<#=mt.m_name#>,
                RmiName_<#= mt.m_name #>,parameterString);

#ifdef VIZAGENT
            m_core->Viz_NotifyRecvToStub(remote, (::Proud::RmiID)Rmi_<#=mt.m_name#>,
                RmiName_<#= mt.m_name #>, parameterString);
#endif
        }
        else if(!m_internalUse)
        {
#ifdef VIZAGENT
            m_core->Viz_NotifyRecvToStub(remote, (::Proud::RmiID)Rmi_<#=mt.m_name#>,
                RmiName_<#= mt.m_name #>, _PNT(""));
#endif
        }

        int64_t __t0 = 0;
        if(!m_internalUse && m_enableStubProfiling)
        {
            ::Proud::BeforeRmiSummary summary;
            summary.m_rmiID = (::Proud::RmiID)Rmi_<#=mt.m_name#>;
            summary.m_rmiName = RmiName_<#= mt.m_name #>;
            summary.m_hostID = remote;
            summary.m_hostTag = hostTag;
            BeforeRmiInvocation(summary);

            __t0 = ::Proud::GetPreciseCurrentTimeMs();
        }

        // Call this method.
        bool __ret = <#=mt.m_name#> (remote,ctx <#+Paramcalls(mt,true);#> );

        if(__ret==false)
        {
            // Error: RMI function that a user did not create has been called.
            m_core->ShowNotImplementedRmiWarning(RmiName_<#= mt.m_name #>);
        }

        if(!m_internalUse && m_enableStubProfiling)
        {
            ::Proud::AfterRmiSummary summary;
            summary.m_rmiID = (::Proud::RmiID)Rmi_<#= mt.m_name #>;
            summary.m_rmiName = RmiName_<#= mt.m_name #>;
            summary.m_hostID = remote;
            summary.m_hostTag = hostTag;
            int64_t __t1;

            __t1 = ::Proud::GetPreciseCurrentTimeMs();

            summary.m_elapsedTime = (uint32_t)(__t1 - __t0);
            AfterRmiInvocation(summary);
        }
    }
    break;
<#+
    } // DoCasePerMethod
#>
<#+ void DeserializeParams(string msgName,Parsed_GlobalInterface gi,Parsed_Method mt)
    {
        foreach(var p in mt.m_params)
        {
#>
<#=p.m_type#> <#=p.m_name#>; <#=msgName#> >> <#=p.m_name#>;
<#+
        }
#>
m_core->PostCheckReadMessage(<#=msgName#>,RmiName_<#=mt.m_name#>);
<#+
    }
#>

<#+ void MakeParameterText(string parameterString,Parsed_Method mt)
    {
        int count=0;
        foreach(var p in mt.m_params)
        {
            if(count > 0)
            {
#>
parameterString += _PNT(", ");
<#+
            }
#>
::Proud::AppendTextOut(parameterString,<#=p.m_name#>);
<#+
            count++;
        }
    }
#>
